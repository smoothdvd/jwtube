/*** Plugin that can help make a callback from embbed page.**/package com.plugins.jwtube {import flash.display.*;import flash.text.*;import flash.net.*;import flash.events.*;import flash.geom.Rectangle;import flash.geom.Point;import flash.external.*;import flash.system.System;import flash.geom.Matrix;import flash.system.Security;import com.jeroenwijering.events.*;import com.pixelfumes.reflect.*;public class JWTube extends MovieClip implements PluginInterface {	/** Reference to the View of the player. **/	private var view:AbstractView;	/** Reference to the graphics. **/	private var clip:MovieClip;	private var shareSp:Sprite;	private var imageLoader:Loader;	private var shareUrlLabel:TextField;	private var shareUrlText:TextField;	private var embedLabel:TextField;	private var embedText:TextField;	private var highlightArea:Shape;	private var recommentXML:XML;	private var imgArray;	private var titleArray;	private var linkArray;	private var imgBitmap:Array = []	private var imagethumb_height = 0;	/** initialize call for backward compatibility. **/	public var initialize:Function = initializePlugin;		/** set iscallback to false, so we can avoid send duplicate view count **/	private var iscallbacked = false;		/** Constructor; nothing going on. **/	public function JWTube() {		Security.allowDomain("*");	};		/** The initialize call is invoked by the player View. **/	public function initializePlugin(vw:AbstractView):void {		view = vw;				//load thumb image to player		imageLoader = new Loader();		var theURL:String;		(view.playlist) ?  theURL = view.playlist[view.config['item']]['image'] : theURL = view.config['image'];		imageLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, imageLoadComplete);		var imageRequest:URLRequest = new URLRequest(theURL);		imageLoader.load(imageRequest);					//load recomment video from xml stream		var XMLloader:URLLoader = new URLLoader();		var request:URLRequest = new URLRequest("images.xml");		XMLloader.load(request);		XMLloader.addEventListener(Event.COMPLETE, XMLloaderComplete);					view.addControllerListener(ControllerEvent.RESIZE,resizeHandler);		view.addModelListener(ModelEvent.STATE,stateHandler);				clip = this;		resizeHandler();	};		private function XMLloaderComplete(event:Event):void {		var loader:URLLoader = event.target as URLLoader;		if (loader != null) {			recommentXML = new XML(loader.data);			//new array to store the path to the images 			imgArray = new Array();			titleArray = new Array();			linkArray = new Array();			var imageLoader:Loader;			var imageRequest:URLRequest;			//when the xml load this is called 			//loop for the number of nodes inside the xml			//xml formate is same as 3.16			for (var i = 0; i < recommentXML.child("recommendation").length(); i++) { 				//populate the imgArray with the images 				imgArray[i] = recommentXML.child("recommendation")[i].child("image");				titleArray[i] = recommentXML.child("recommendation")[i].child("title");				linkArray[i] = recommentXML.child("recommendation")[i].child("link");						imageLoader = new Loader();				imageLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, imgArrayLoadComplete);				imageRequest = new URLRequest(imgArray[i]);								imageLoader.load(imageRequest);			}		}			}		private function imageLoadComplete(event:Event):void {		var loader:Loader = Loader(event.target.loader);        var image:Bitmap = Bitmap(loader.content);		image.smoothing = true;		image.width = view.config['width']-210;		image.height = image.width*0.75;				image.x = 20;		image.y = 20;		imagethumb_height = image.height;	}		private function imgArrayLoadComplete(event:Event):void {		var loader:Loader = Loader(event.target.loader);        var image:Bitmap = Bitmap(loader.content);		image.smoothing = true;		imgBitmap.push(image);	}		/** fired when the Share Url is clicked **/	private function clickSelectCopyHandler(evt:MouseEvent=null) {		var tf:TextField = TextField(evt.currentTarget);		tf.setSelection(0, tf.text.length);		System.setClipboard(tf.text);	};		/** Handle a resize. **/	private function resizeHandler(evt:ControllerEvent=undefined) {		if (highlightArea != null) {			highlightArea.width = view.config['width'];			highlightArea.height = view.config['height'];			shareUrlLabel.x = shareUrlText.x = embedLabel.x = embedText.x = view.config['width'] - 180;			shareUrlLabel.y = 20;			shareUrlText.y = shareUrlLabel.y + shareUrlLabel.height + 5;			embedLabel.y = shareUrlText.y + shareUrlLabel.height + 5;			embedText.y = embedLabel.y + embedLabel.height + 5;			var image:Bitmap = Bitmap(imageLoader.content);			image.smoothing = true;			image.width = view.config['width']-210;			image.height = image.width*0.75;						image.x = 20;			image.y = 20;		}	};		private function stateHandler(evt:ModelEvent):void {    	// Do something here when the STATE has Changed.		switch(evt.data.newstate) {			case ModelStates.BUFFERING:				if (shareSp != null) {					shareSp.visible = false;				}				break;			case ModelStates.PLAYING:				//add hard code of callback				if (shareSp != null) {					shareSp.visible = false;				}								if ( !iscallbacked ) {					iscallbacked = true;					//url of server-side script can be configured in flashvar named jwtube.callback					//server-side script can accept following post params					//"state": the video's play state, when it is in 'start' state, callback will fired					//"file": the video's name in flashvar					//'referer": optional, the referer of video from					//if you want to know how to get referer of swf, please send email to me: madfxgao@gmail.com					var myData:URLRequest = new URLRequest(view.config['jwtube.callback']);					myData.method = URLRequestMethod.POST;					var variables:URLVariables = new URLVariables();					variables.file = view.playlist[view.config['item']]['file'];					variables.state = "start";					//worked need to set "allowscriptaccess" to "always"					//variables.externallink = String( ExternalInterface.call(" function(){ return document.location.href.toString();}"));					myData.data = variables;					var loader:URLLoader = new URLLoader();					loader.dataFormat = URLLoaderDataFormat.VARIABLES;					loader.load(myData);				}				break;			case ModelStates.COMPLETED:				shareUrlLabel = new TextField();				shareUrlText = new TextField();				embedLabel = new TextField();				embedText = new TextField();				highlightArea = new Shape();				//get filename part, my own filename formate: */xxxxxxxxxxx.flv				//var filename:String = view.playlist[view.config['item']]['file'];				//filename = filename.substr(filename.lastIndexOf("/")+1, filename.lastIndexOf(".")-filename.lastIndexOf("/")-1);				//add backgroud to player				highlightArea.graphics.beginFill(0x000000, 0.7);				highlightArea.graphics.lineStyle(0);				highlightArea.graphics.drawRect(0, 0, view.config['width'], view.config['height']);				highlightArea.graphics.endFill();				//add url lable to player				shareUrlLabel.x = view.config['width'] - 180;				shareUrlLabel.y = 20;				shareUrlLabel.height = 20;				shareUrlLabel.text = "链接";				shareUrlLabel.selectable = false;				shareUrlLabel.textColor = 0xFFFFFF;				var shareUrlLabel_txtfmt:TextFormat = new TextFormat();				shareUrlLabel_txtfmt.size = 12;				shareUrlLabel_txtfmt.font = "_sans";				shareUrlLabel.setTextFormat(shareUrlLabel_txtfmt);				//add url text field to player				shareUrlText.width = 160;				shareUrlText.height = 20;				shareUrlText.x = view.config['width'] - 20 - shareUrlText.width;				shareUrlText.y = shareUrlLabel.y + shareUrlLabel.height + 5;				//my video watch page's url				//shareUrlText.text = "http://v.rjhz.com.cn/watch?v=" + filename;				//jwtube.url: url the video's link page				shareUrlText.text = view.config['jwtube.url'];				var shareUrlText_txtfmt:TextFormat = new TextFormat();				shareUrlText_txtfmt.size = 12;				shareUrlText_txtfmt.font = "_sans";				shareUrlText.setTextFormat(shareUrlText_txtfmt);				shareUrlText.background = true;				shareUrlText.backgroundColor = 0xDDDDDD;				shareUrlText.addEventListener(MouseEvent.CLICK,clickSelectCopyHandler)				shareUrlText.addEventListener(MouseEvent.MOUSE_UP,clickSelectCopyHandler)				//add embed lable to player				embedLabel.x = view.config['width'] - 180;				embedLabel.y = shareUrlText.y + shareUrlLabel.height + 5;				embedLabel.height = 20;				embedLabel.text = "分享";				embedLabel.selectable = false;				embedLabel.textColor = 0xFFFFFF;				var embedLabel_txtfmt:TextFormat = new TextFormat();				embedLabel_txtfmt.size = 12;				embedLabel_txtfmt.font = "_sans";				embedLabel.setTextFormat(embedLabel_txtfmt);				//add embed text field to player				embedText.width = 160;				embedText.height = 80;				embedText.x = view.config['width'] - 20 - embedText.width;				embedText.y = embedLabel.y + embedLabel.height + 5;				//my embed code				//jwtube.swf: url of video file, I use apache's rewrite mod to fool jwplayer				embedText.text = '<object width="448" height="356"><param name="movie" value="' + view.config['jwtube.swf'] + '"></param><param name="wmode" value="transparent"></param><param name="allowscriptaccess" value="always"></param><param name="allowfullscreen" value="true"></param><param name="quality" value="high"></param><param name="bgcolor" value="#000000"></param><embed allowscriptaccess="always" allowfullscreen="true" quality="high" bgcolor="#000000" src="' + view.config['jwtube.swf'] + '" type="application/x-shockwave-flash" wmode="transparent" width="448" height="356"></embed></object>';				var embedText_txtfmt:TextFormat = new TextFormat();				embedText_txtfmt.size = 12;				embedText_txtfmt.font = "_sans";				embedText.wordWrap = true;				embedText.setTextFormat(embedText_txtfmt);				embedText.background = true;				embedText.backgroundColor = 0xDDDDDD;				embedText.addEventListener(MouseEvent.CLICK,clickSelectCopyHandler)				embedText.addEventListener(MouseEvent.MOUSE_UP,clickSelectCopyHandler)				shareSp = new Sprite();				shareSp.addChild(highlightArea);				shareSp.addChild(imageLoader);				shareSp.addChild(shareUrlLabel);				shareSp.addChild(shareUrlText);				shareSp.addChild(embedLabel);				shareSp.addChild(embedText);								//Show the recomment video thumb, not finished																//var imagethumb:Bitmap = Bitmap(imageLoader.content);				var height_recomment, width_recomment;				width_recomment = (view.config['width'] - 40) / imgBitmap.length - 5;				if (width_recomment < 48) {					width_recomment = 48;				} else if (width_recomment > 96) {					width_recomment = 96;				}				height_recomment = (width_recomment) * 0.75;				for (var i=0;i<imgBitmap.length;i++) {										//the BitmapData object that will hold a visual copy of the mc					var mcBMP:BitmapData;					//the BitmapData object that will hold the reflected image					var reflectionBMP:Bitmap;					//the clip that will act as out gradient mask					var gradientMask_mc:MovieClip;					//how often the reflection should update (if it is video or animated)					var updateInt:Number;					//the size the reflection is allowed to reflect within					var bounds:Object;					//the distance the reflection is vertically from the mc					var distance:Number = 0;					//the ratio opaque color used in the gradient mask					var ratio:Number = 128;					//the distance at which the reflection visually drops off at					var reflectionDropoff:Number = 0;					//the alpha level of the reflection clip					var alpha:Number = 50/100;					//store the bounds of the reflection					bounds = new Object();					bounds.width = width_recomment;					bounds.height = height_recomment;														imgBitmap[i].height = height_recomment;					imgBitmap[i].width = width_recomment;					imgBitmap[i].x = 20 + i*(imgBitmap[i].width+5);					imgBitmap[i].y = view.config['height'] - 40 - imgBitmap[i].height;					var thi:DisplayObject = shareSp.addChild(imgBitmap[i]);															//create the BitmapData that will hold a snapshot of the movie clip					mcBMP = new BitmapData(bounds.width, bounds.height, true, 0x000000);					//mcBMP = imgBitmap[i].bitmapData.clone();					var matrix:Matrix = new Matrix();					matrix.scale(imgBitmap[i].scaleX, imgBitmap[i].scaleY);					mcBMP.draw(thi, matrix);					//create the BitmapData the will hold the reflection					reflectionBMP = new Bitmap(mcBMP);					//flip the reflection upside down					reflectionBMP.scaleY = -1;					//move the reflection to the bottom of the movie clip					reflectionBMP.y = imgBitmap[i].y + imgBitmap[i].height*2 + distance;					reflectionBMP.x = imgBitmap[i].x										//add the reflection to the movie clip's Display Stack					var reflectionBMPRef:DisplayObject = shareSp.addChild(reflectionBMP);					//reflectionBMPRef.name = "reflectionBMP";										//add a blank movie clip to hold our gradient mask					var gradientMaskRef:DisplayObject = shareSp.addChild(new MovieClip());					//gradientMaskRef.name = "gradientMask_mc";										//get a reference to the movie clip - cast the DisplayObject that is returned as a MovieClip					gradientMask_mc = gradientMaskRef as MovieClip;					//set the values for the gradient fill					var fillType:String = GradientType.LINEAR;					var colors:Array = [0xFFFFFF, 0xFFFFFF];					var alphas:Array = [alpha, 0];					var ratios:Array = [0, ratio];					var spreadMethod:String = SpreadMethod.PAD;					//create the Matrix and create the gradient box					var matr:Matrix = new Matrix();					//set the height of the Matrix used for the gradient mask					var matrixHeight:Number;					if (reflectionDropoff<=0) {						matrixHeight = bounds.height;					} else {						matrixHeight = bounds.height/reflectionDropoff;					}					matr.createGradientBox(bounds.width, matrixHeight, (90/180)*Math.PI, 0, 0);					//create the gradient fill					gradientMask_mc.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);  					gradientMask_mc.graphics.drawRect(0,0,bounds.width*4+35,bounds.height);					//position the mask over the reflection clip								gradientMask_mc.y = reflectionBMP.y - reflectionBMP.height;					//cache clip as a bitmap so that the gradient mask will function					gradientMask_mc.cacheAsBitmap = true;					reflectionBMP.cacheAsBitmap = true;					//set the mask for the reflection as the gradient mask					reflectionBMP.mask = gradientMask_mc;				}				addChild(shareSp); 				break;		}	};}}